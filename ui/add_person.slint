import { ListView, Button, VerticalBox, LineEdit, ComboBox, HorizontalBox } from "std-widgets.slint";
import { PersonData, GroupData } from "types.slint";

// Custom lightweight dropdown.
//
// Why not use the standard ComboBox?
// The intent here is to have explicit "changed" signaling under our control
// (no timer/polling), so the Rust side can recompute the filtered persons list
// when the selected group changes.
export component GroupComboBox inherits VerticalBox {
    in-out property <[string]> entries;
    in-out property <int> current: -1;
    callback changed(int);
    property <bool> open: false;

    Rectangle {
        height: 28px;
        width: parent.width;
        background: #252525;
        border-radius: 4px;
        HorizontalBox {
            spacing: 6px;
            padding: 4px;
            if current >= 0 && current < entries.length: Text { text: entries[current]; vertical-alignment: center; }
            if !(current >= 0 && current < entries.length): Text { text: @tr("SELECT_GROUP"); vertical-alignment: center; }
            Text { text: open ? "▲" : "▼"; vertical-alignment: center; }
        }
        TouchArea { clicked => { open = !open; } }
    }
    if open: VerticalBox {
        spacing: 4px;
        for e[i] in entries: Rectangle {
            height: 26px;
            width: parent.width;
            background: i == current ? #333333 : #252525;
            border-radius: 4px;
            Text { text: e; vertical-alignment: center; }
            TouchArea { clicked => { current = i; open = false; root.changed(current); } }
        }
    }
}

export component AddPersonPage inherits Window {
    width: 340px;
    height: 380px;
    title: @tr("ADD_PERSON");

    in-out property <string> name;
    in-out property <string> surname;
    in-out property <int> rank;
    in-out property <int> methodology;
    property <bool> can_submit: !name.is-empty && !surname.is-empty;

    // These callbacks are wired by the main app:
    // - exit: close the modal and discard changes
    // - submit: validate + send data to Rust via callback

    callback exit();
    callback submit();

    Rectangle {
        border-width: 2px;
        border-color: white;

        Button {
            x: parent.width - 60px;
            y: 10px;
            icon: @image-url("./../assets/images/close.svg");
            colorize-icon: true;
            clicked => { root.exit(); }
        }

        VerticalBox {
            spacing: 8px;
            padding: 12px;
            padding-top: 30px;

            Text { text: @tr("INPUT_NAME"); }
            LineEdit { text <=> root.name; }

            Text { text: @tr("INPUT_SURNAME"); }
            LineEdit { text <=> root.surname; }

            Text { text: @tr("RANK"); }
            ComboBox {
                current-index <=> root.rank;
                model: [
                    "RANK_NONE",
                    "RANK_FIRST_MALE",
                    "RANK_FIRST_FEMALE",
                    "RANK_SECOND_MALE",
                    "RANK_SECOND_FEMALE",
                    "RANK_THIRD_MALE",
                    "RANK_THIRD_FEMALE",
                    "RANK_FOURTH_MALE",
                    "RANK_FOURTH_FEMALE",
                    "RANK_FIFTH",
                    "RANK_SIXTH"
                ];
            }

            Text { text: @tr("METHODOLOGY"); }
            ComboBox {
                current-index <=> root.methodology;
                model: [
                    "CUB",
                    "SCOUT",
                    "VENTURESCOUT",
                    "ROVER"
                ];
            }

            Button {
                text: @tr("ADD_PERSON");
                enabled: can_submit;
                clicked => { root.submit(); }
            }
        }
    }
}

export component AddGroupPage inherits Window {
    width: 340px;
    height: 180px;
    title: @tr("ADD_GROUP");

    in-out property <string> name;
    property <bool> can_submit: !name.is-empty;

    callback exit();
    callback submit();

    Rectangle {
        border-width: 2px;
        border-color: white;

        Button {
            x: parent.width - 60px;
            y: 10px;
            icon: @image-url("./../assets/images/close.svg");
            colorize-icon: true;
            clicked => { root.exit(); }
        }

        VerticalBox {
            spacing: 8px;
            padding: 12px;
            padding-top: 30px;

            Text { text: @tr("INPUT_NAME"); }
            LineEdit { text <=> root.name; }

            Button {
                text: @tr("ADD_GROUP");
                enabled: can_submit;
                clicked => { root.submit(); }
            }
        }
    }
}

export component AddPersonToGroupPage inherits Window {
    width: 340px;
    height: 320px;
    title: @tr("ADD_PERSON_TO_GROUP");

    in-out property <[PersonData]> persons; // original full list
    in-out property <[PersonData]> filtered_persons; // filtered list
    in-out property <[GroupData]> groups;
    in-out property <[string]> groups_names;

    // Selection indices into `filtered_persons` and `groups_names`.
    // Rust converts them to actual IDs when submitting.

    in-out property <int> person;
    in-out property <int> group;
    property <bool> can_submit: true;

    callback group_selection_changed(int);

    // `group_selection_changed` is forwarded to MainWindow.
    // Rust then updates `filtered_persons` to exclude people already in the chosen group.

    callback check();
    callback exit();
    callback submit();


    Rectangle {
        border-width: 2px;
        border-color: white;

        Button {
            x: parent.width - 60px;
            y: 10px;
            icon: @image-url("./../assets/images/close.svg");
            colorize-icon: true;
            clicked => { root.exit(); }
        }

        VerticalBox {
            spacing: 8px;
            padding: 12px;
            padding-top: 30px;

            Text { text: @tr("CHOOSE_GROUP"); }
            GroupComboBox {
                entries <=> groups_names;
                current <=> root.group;
                changed => { root.group_selection_changed(root.group); }
            }
            // Auto-filter handled by component-level group-changed handler below

            Text { text: @tr("CHOOSE_PERSON"); }
            if filtered_persons.length == 0: Rectangle {
                width: parent.width - 24px;
                height: 140px;
                Text { text: @tr("NO_AVAILABLE_PERSONS"); color: #999999; horizontal-alignment: center; vertical-alignment: center; }
            }
            if filtered_persons.length > 0: ListView {
                width: parent.width - 24px;
                height: 140px;
                for p[index] in filtered_persons: Rectangle {
                    height: 32px;
                    background: index == root.person ? #333333 : #252525;
                    border-radius: 6px;
                    HorizontalBox {
                        spacing: 8px;
                        Rectangle {
                            width: 14px; height: 14px; border-radius: 7px;
                            background: p.methodology;
                        }
                        Text { text: p.rank + " " + p.surname + " " + p.name; vertical-alignment: center; }
                    }
                    TouchArea { clicked => { root.person = index; } }
                }
            }

            Button {
                text: @tr("ADD_GROUP");
                enabled: can_submit && root.person >= 0 && root.group >= 0;
                clicked => { root.submit(); }
            }
        }
    }
}
